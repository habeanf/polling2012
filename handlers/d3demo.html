<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="/static/d3.js"></script>
    <style type="text/css">

        svg {
          font-family: "Helvetica Neue", Helvetica;
        }

        .line {
          fill: none;
          stroke: #000;
          stroke-width: 2px;
        }

    </style>
  </head>
    <body>
    	<script type="text/javascript">
    	var data                = {{data}};
      var preferences         = {LVRV:'LV'};
      var SWING_MARGIN_PCT    = 6;
      var POLL_DEFAULT_MARGIN = 4;
      var ISOSUFFIX           = "T00:00:00";

      // bahhh how does Math not have sign builtin?
      _sign = function(x) {
        if (x < 0) return -1;
        if (x > 0) return  1;
        return 0;
      }
      // parse date objects for later use; new Date(x) expects can parse x if x is isoformat (YYYY-MM-DD...)
      data.forEach(function (state) {
        state.polls.forEach(function (poll) {
          poll.fromDate = new Date(poll.fromDate + ISOSUFFIX);
          poll.toDate   = new Date(poll.toDate + ISOSUFFIX);
        });
      });

      // calculates the a-priori type of state (swing / safe, if swing adds the type)
      // a safe state has voted the same in the last two election by a margin larger than SWING_MARGIN_PCT
      // wikipedia article http://en.wikipedia.org/wiki/Swing_state uses 6 pct as the safe/swing differentiator
      function calculateStateApriori(state) {
        if (state[2004][0] == state[2008][0] &&
            state[2004][1][0]-state[2004][1][1] > SWING_MARGIN_PCT &&
            state[2008][1][0]-state[2008][1][1] > SWING_MARGIN_PCT)
          state.apriori = state[2004][0] + ' Safe';
        else
          state.apriori = 'Unknown'; // Swing states have unknown outcomes
      }

      function calculatePollOutcome(poll) {
        var pollValue = 'Unknown';
        var margin    = poll.margin || POLL_DEFAULT_MARGIN;
        var swing     = poll.results.lead_margin < margin;
        var winner    = 'Unknown';
        if (poll.results.republican_pct>poll.results.democrat_pct)
            winner = 'Republican';
        if (poll.results.republican_pct<poll.results.democrat_pct)
            winner = 'Democratic';
        if (winner != 'Unknown') {
            pollValue = winner;
            if (swing)
                pollValue += ' Swing';
            else
                pollValue += ' Safe';
        }
        poll.outcome = pollValue;
      }

      // TODO: need to use preferences to choose polls
      function choosePoll(polls) {
        return polls[0].values[0];
      }

      // some states have multiple polls ending on the same day
      // sometimes these polls have different sampling types
      // - Registered Voters (RV) vs Likely Voters (LV)
      // - Different pollers (e.g. Rasmussen vs Gallup)
      // if they have different outcomes, we should choose one (since each outcome has it's own bucket)
      function processPolls(stateData) {
        stateData.polls.forEach(calculatePollOutcome)
        var nestedByEndDay  = d3.nest()
                                .key(function (poll) {return poll.toDate;})
                                .key(function (poll) {return poll.outcome;})
                                .entries(stateData.polls);
        nestedByEndDay.forEach(function(polledday) {
          if (polledday.values.length>1) {
            // there are indeed multiple polls for the same day
            // if they have different outcomes, we need to choose one
            polledday.result = choosePoll(polledday.values);
          }
          else
            polledday.result = polledday.values[0].values[0];
        });

        return nestedByEndDay
                .map(function (dayData) {return dayData.result})
                .sort(function (poll1,poll2) {
                  return _sign(poll1.toDate-poll2.toDate);
                });
      }

      function extendLastPoll(polls,enddate) {
        var lastPollResult = polls.slice(-1)[0];

        interpolated_range = d3.time.day.range(d3.time.day.offset(lastPollResult.date,1),enddate)
                                        .map(function(d) { 
                                              return {state:lastPollResult.state,
                                                      date:d,
                                                      value:lastPollResult.value,
                                                      outcome:lastPollResult.outcome};}
                                            );
        return polls.concat(interpolated_range)
      }

      // generate a timeline from jan 1st until the current day of predicted state outcome for a state
      function generateDaily(stateData) {
        calculateStateApriori(stateData);
        var processedPolls = processPolls(stateData);
        dailyData = processedPolls.reduce(function (previousResults,currentPoll) {
            var lastPollResult = previousResults.slice(-1)[0];

            var pollDate = currentPoll.toDate;
            var pollOutcome = currentPoll.outcome;

            var newResult = extendLastPoll(previousResults,pollDate);
            newResult.push({state:stateData.name,date:pollDate,outcome:pollOutcome,value:stateData.votes});
            return newResult;
        },[{state:stateData.name,date:new Date('2012-01-01T00:00:00'),outcome:stateData.apriori,value:stateData.votes}]) 
        return extendLastPoll(dailyData,new Date());
      }

      // generate the timelines of all states
      function generateStateData() {
        return data.map(function (state) {return generateDaily(state);});
      }

      // aggregate by category from the state timelines
      function generateCategoryData() {
        var dataByState           = generateStateData();
        var flattenedPollResults  = dataByState.reduce(function (previousStates,currentState) {
          return previousStates.concat(currentState);
        },[]);
        var nestedByPollDayResult = d3.nest()
                                      .key(function (poll) { return poll.outcome;})
                                      .key(function (poll) { return poll.date;})
                                      .entries(flattenedPollResults);
        nestedByPollDayResult.forEach(function (outcome) {
          // calculate total for each day
          outcome.values.forEach(function (outComeDay) {
            outComeDay.value = outComeDay.values.reduce(function (previous,current) {
                                                          return previous+current.value;
                                                        },0);
            delete outComeDay['values'];
          });

          // fill in missing days
          // step 1: sort
          outcome.values.sort(function (day1,day2) {
            return _sign((new Date(day1.key)) - (new Date(day2.key)));
          });

          // step 2: fill in the blanks
          outcome.values = outcome.values.reduce(
            function (prev,curr) {
              var last = prev.slice(-1)[0];
              var interpolated_blank = d3.time.days( d3.time.day.offset(new Date(last.key),1),
                                                     new Date(curr.key))
                                              .map(function (d) {
                                                  return {key:d.toString(),
                                                          value:last.value};
                                                });
              var newprevious = prev.concat(interpolated_blank);
              newprevious.push(curr);
              return newprevious;
          },[{key:"2011-12-31"+ISOSUFFIX,value:0}]).splice(1);

          // pad the end
          var last = outcome.values.slice(-1)[0];
          var lastDate = new Date(last.key);
          var today = new Date();
          var interpolated_end = d3.time.days(d3.time.day.offset(lastDate,1),
                                              d3.time.day.offset(today,-1))
                                        .map(function (d) {
                                          return {key:d.toString(),
                                                  value:last.value};
                                        });
          outcome.values.concat(interpolated_end);
        });
        return nestedByPollDayResult;
      }

    	var xAxis = [];
    	var today = new Date();
    	for (var x=1; x<61; x++){
    		var daDate = new Date( today - 86400000 * x );
    		xAxis.push( [daDate.getFullYear(),daDate.getMonth()+1,daDate.getDate()].join('/') );
    	}
    	yAxis = {
    		DemocratsAssured : "Democrats Assured",
    		DemocratsHanging : "Democrats Hanging",
    		DemocratesDispute : "Democrats Disputed",
    		Disputed : "Disputed",
    		RepublicanDispute : "Republicans Disputed",
    		RepublicansHanging: "Republicans Hanging",
    		RepublicansAssured : "Republicans Assured"
    	}

    	var totalWeights = 538;
    	




    	</script>
    </body>
</html>


