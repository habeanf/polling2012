<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <script type="text/javascript" src="/static/d3.v2.js"></script>
    <style type="text/css">


        body {
          font: 10px sans-serif;
        }

        .axis path, .axis line {
          fill: none;
          stroke: #000;
          shape-rendering: crispEdges;
        }

    </style>
    <title>US Polling 2012</title>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', '{{ga_id}}']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>    
  </head>
    <body>
      <a href="https://github.com/habeanf/polling2012"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png" alt="Fork me on GitHub"></a>
      <h1>2012 Presidential Elections</h1>
      <h2>US Statewide Polling</h2>
      <h3>Last Update: {{lastupdate}}</h3>
      <svg class="graphsvg"></svg>
      <p>Red - Romney / Ryan <br/>Blue - Obama / Biden</p>
    	<script type="text/javascript">
    	var data                = {{data}};
      var preferences         = {LVRV:'LV',polltype:-1};
      var SWING_MARGIN_PCT    = 6;
      var POLL_DEFAULT_MARGIN = 4;
      var UNKNOWN_STATES      =
      [{name:'Alaska',votes:3,polls:[],
        2004:['Republican',[61.1,35.5]],
        2008:['Republican',[59.4,37.9]]},
       {name:'Delaware',votes:3,polls:[],
        2004:['Democratic',[53.4,45.8]],
        2008:['Democratic',[61.9,36.9]]},
       {name:'DC',votes:3,polls:[],
        2004:['Democratic',[89,9]],
        2008:['Democratic',[92.46,6.53]]},
       {name:'Idaho',votes:4,polls:[],
        2004:['Republican',[68.4,30.3]],
        2008:['Republican',[61.3,36]]},
       {name:'Wyoming',votes:3,polls:[],
        2004:['Republican',[68.9,29.1]],
        2008:['Republican',[64.8,32.5]]}];
        
      // bahhh how does Math not have sign builtin?
      _sign = function(x) {
        if (x < 0) return -1;
        if (x > 0) return  1;
        return 0;
      }

      function flatten(nested) {
        return nested.reduce(function (prev,curr) {
          return prev.concat(curr.values);
        },[]);
      }
      var internalDateFormat = d3.time.format("%Y-%m-%d");
      function getData(dateString) {
        var dateSplit = dateString.split('-');
        //return new Date(Date.UTC(parseInt(dateSplit[0]),parseInt(dateSplit[1]),parseInt(dateSplit[2]),-2,0,0));
        return internalDateFormat.parse(dateString);
      }

      // parse date objects for later use; new Date(x) expects can parse x if x is isoformat (YYYY-MM-DD...)
      data.forEach(function (state) {
        state.polls.forEach(function (poll) {
          poll.fromDate = getData(poll.fromDate);
          poll.toDate   = getData(poll.toDate);;
        });
      });

      // calculates the a-priori type of state (swing / safe, if swing adds the type)
      // a safe state has voted the same in the last two election by a margin larger than SWING_MARGIN_PCT
      // wikipedia article http://en.wikipedia.org/wiki/Swing_state uses 6 pct as the safe/swing differentiator
      function calculateStateApriori(state) {
        if (state[2004][0] == state[2008][0] &&
            state[2004][1][0]-state[2004][1][1] > SWING_MARGIN_PCT &&
            state[2008][1][0]-state[2008][1][1] > SWING_MARGIN_PCT)
          state.apriori = state[2004][0] + ' Safe';
        else
          state.apriori = 'Unknown'; // Swing states have unknown outcomes
      }

      function calculatePollOutcome(poll) {
        var pollValue = 'Unknown';
        var margin    = poll.margin || POLL_DEFAULT_MARGIN;
        var swing     = poll.results.lead_margin < margin;
        var winner    = 'Unknown';
        if (poll.results.republican_pct>poll.results.democrat_pct)
            winner = 'Republican';
        if (poll.results.republican_pct<poll.results.democrat_pct)
            winner = 'Democratic';
        if (winner != 'Unknown') {
            pollValue = winner;
            if (swing)
                pollValue += ' Swing';
            else
                pollValue += ' Safe';
        }
        poll.outcome = pollValue;
      }

      // TODO: need to use preferences to choose polls
      function choosePoll(polls) {
        var allpolls = flatten(polls)
        return allpolls.slice(preferences.polltype)[0];
      }

      // some states have multiple polls ending on the same day
      // sometimes these polls have different sampling types
      // - Registered Voters (RV) vs Likely Voters (LV)
      // - Different pollers (e.g. Rasmussen vs Gallup)
      // if they have different outcomes, we should choose one (since each outcome has it's own bucket)
      function processPolls(stateData) {
        stateData.polls.forEach(calculatePollOutcome)
        var nestedByEndDay  = d3.nest()
                                .key(function (poll) {return poll.toDate;})
                                .key(function (poll) {return poll.outcome;})
                                .entries(stateData.polls);
        nestedByEndDay.forEach(function(polledday) {
          if (polledday.values.length>1) {
            // there are indeed multiple polls for the same day
            // if they have different outcomes, we need to choose one
            polledday.result = choosePoll(polledday.values);
          }
          else
            polledday.result = polledday.values[0].values[0];
        });

        return nestedByEndDay
                .map(function (dayData) {return dayData.result})
                .sort(function (poll1,poll2) {
                  return _sign(poll1.toDate-poll2.toDate);
                });
      }

      function extendLastPoll(polls,enddate) {
        var lastPollResult = polls.slice(-1)[0];

        interpolated_range = d3.time.day.range(d3.time.day.offset(lastPollResult.date,1),enddate)
                                        .map(function(d) { 
                                              return {state:lastPollResult.state,
                                                      date:d,
                                                      value:lastPollResult.value,
                                                      outcome:lastPollResult.outcome};}
                                            );
        return polls.concat(interpolated_range)
      }

      // generate a timeline from jan 1st until the current day of predicted state outcome for a state
      function generateDaily(stateData) {
        calculateStateApriori(stateData);
        var processedPolls = processPolls(stateData);
        dailyData = processedPolls.reduce(function (previousResults,currentPoll) {
            var lastPollResult = previousResults.slice(-1)[0];

            var pollDate = currentPoll.toDate;
            var pollOutcome = currentPoll.outcome;

            var newResult = extendLastPoll(previousResults,pollDate);
            newResult.push({state:stateData.name,date:pollDate,
                            outcome:pollOutcome,value:stateData.votes});
            
            return newResult;
        },[{state:stateData.name,date:getData('2012-01-01'),
            outcome:stateData.apriori,value:stateData.votes}]) 
        return extendLastPoll(dailyData,new Date());
      }

      // generate the timelines of all states
      function generateStateData() {
        return data.concat(UNKNOWN_STATES).map(function (state) {return generateDaily(state);});
      }

      // aggregate by category from the state timelines
      function generateCategoryData() {
        var dataByState           = generateStateData();
        var flattenedPollResults  = dataByState.reduce(function (previousStates,currentState) {
          return previousStates.concat(currentState);
        },[]);
        var nestedByPollDayResult = d3.nest()
                                      .key(function (poll) { return poll.outcome;})
                                      .key(function (poll) { return poll.date;})
                                      .entries(flattenedPollResults);
        nestedByPollDayResult.forEach(function (outcome) {
          // calculate total for each day
          outcome.values.forEach(function (outComeDay) {
            outComeDay.value = outComeDay.values.reduce(function (previous,current) {
                                                          return previous+current.value;
                                                        },0);
            //console.log("For")
          });

          // fill in missing days
          //  step 1: sort
          outcome.values.sort(function (day1,day2) {
            return _sign((new Date(day1.key)) - (new Date(day2.key)));
          });

          //  step 2: fill in the blanks
          outcome.values = outcome.values.reduce(
            function (prev,curr) {
              var last = prev.slice(-1)[0];
              curr['date'] = new Date(curr.key);              
              curr['key']=outcome.key;
              var interpolated_blank = d3.time.days( d3.time.day.offset(
                                                        new Date(last.date),1),
                                                     new Date(curr.date))
                                              .map(function (d) {
                                                  return {key:outcome.key,
                                                          date:d,
                                                          value:0};
                                                });
              var newprevious = prev.concat(interpolated_blank);              
              newprevious.push(curr);
              return newprevious;
          },[{date:getData("2011-12-31"),value:0,key:outcome.key}]).splice(1);

          // pad the end
          var last = outcome.values.slice(-1)[0];
          var lastDate = last.date;
          var today = new Date();
          var interpolated_end = d3.time.days(d3.time.day.offset(lastDate,1),
                                              d3.time.day.offset(today,-1))
                                        .map(function (d) {
                                          return {date:d,
                                                  value:last.value,
                                                  key:outcome.key};
                                        });
          outcome.values.concat(interpolated_end);
        });
        return nestedByPollDayResult;
      }

      var stack = d3.layout.stack()
          .offset("zero")
          .values(function(d) { return d.values; })
          .x(function(d) { return d.date; })
          .y(function(d) { return d.value; });


      function calculateData() {
        sdata = generateCategoryData();

        var sortorder   = { 'Republican Safe':5,
                            'Republican Swing':4,
                            'Unknown':3,
                            'Democratic Swing':2,
                            'Democratic Safe':1
                          };
        sdata.sort(function (l,r) {
          return _sign(sortorder[l.key]-sortorder[r.key]);
        });
        
        fdata = flatten(sdata);
        layers = stack(sdata);

      }
      calculateData();

      var margin = {top: 20, right: 30, bottom: 30, left: 40},
          width = 960 - margin.left - margin.right,
          height = 500 - margin.top - margin.bottom;

      var x = d3.time.scale()
          .range([0, width]);

      var y = d3.scale.linear()
          .range([height, 0]);

      var z = d3.scale.ordinal()
          .range(['#3182bd','#6baed6','#dddddd','#fdae6b','#e6550d' ]);

      var yAxis = d3.svg.axis()
          .scale(y)
          .orient("left")
          .tickValues([135,270,403,538]);

      var yAxis2 = d3.svg.axis()
          .scale(y)
          .orient("right")
          .tickValues([135,270,403,538]);

      var area = d3.svg.area()
          .interpolate("cardinal")
          .x(function(d) { return x(d.date); })
          .y0(function(d) { return y(d.y0); })
          .y1(function(d) { return y(d.y0 + d.y); });

      var svg = d3.select(".graphsvg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom)
        .append("g")
          .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      x.domain(d3.extent(fdata, function(d) { return d.date; }));
      y.domain([0, d3.max(fdata, function(d) { return d.y0 + d.y; })]);


      var xAxis = d3.svg.axis()
          .scale(x)
          .orient("bottom")
          .ticks(d3.time.months);

      svg.selectAll(".layer")
          .data(layers)
        .enter().append("path")
          .attr("class", "layer")
          .attr("d", function(d) { return area(d.values); })
          .style("fill", function(d, i) { return z(i); });

      svg.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      svg.append("g")
          .attr("class", "y axis")
          .call(yAxis);
      
      svg.append("g")
          .attr("class", "y axis")
          .attr("transform", "translate(" + width + ",0)")
          .call(yAxis2);
      
      function transition() {
        preferences.polltype=preferences.polltype*-1 - 1;
        duration = 1500;
        calculateData();
        d3.selectAll(".layer")
        .data(layers)
        .transition()
        .duration(duration)
        .attr("d",function(d) { return area(d.values);})
        .attr("fill", function (d, i) { return z(i); });
      }

    	</script>
    </body>
</html>


